#---------------------------------------------------------
# This script encapsulates most plotting function for the 
# figures in the manuscript--specfically Figures 1,2,7,8
# and 9. 
#
# The figures generated by this script are focused on the
# methodology itself, and its application. All comparison
# figures are generated in Evaluate.py.
#
# Author: Vicente Salinas
# Contact: vicente.salinas@noaa.gov
# Updated: 04/18/2023
#---------------------------------------------------------

#----------------
#Required Imports
#----------------
#Basic + tracking backend
import numpy as np
import xarray as xr
import backend as bk
import datetime as dt

#Image manipulation
from scipy.ndimage import gaussian_filter as gf
from scipy.interpolate import griddata, interpn
from skimage.filters import threshold_otsu

#Mapping
from   cartopy.io.shapereader import Reader
import cartopy.crs as ccrs
import cartopy as ct
import cartopy.feature as cfeature

#Plotting
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import cmocean as cm
import seaborn as sns
sns.reset_orig()

#################################################################
#OTHER: COORD TRANSFORMATIONS AND FED THRESHOLDING.             #
#################################################################
#---------------------------
#COORDINATE TRANSFORMATIONS
#---------------------------
def get_lonlats(x,y,z,geo,proj):
    '''
    Function to transform gridded or sample grid coordinates to LMA network relative
    cartesian coordinates. 
    
    Accepts x,y,z as cartesian coordinates and returns them back to geographic coordinates lon_x,lon_y,alt_z for overalying
    onto maps. Note: coordinates must be in units meters (not kilometers).
    '''
    ecefx,ecefy,ecefz = proj.toECEF(x,y,z)
    lon_x,lat_y,alt_z = geo.fromECEF(ecefx,ecefy,ecefz)
    return(lon_x,lat_y,alt_z)

#------------------------
#OTSUS THRESHOLDING
#------------------------
#Define subplot for drawing the distribution (and histogram) associated with each time intervals Otsu's threshold value at 
#the same time frame used in the figure above
def otsu_plots(ax,field,bins,height_guess):
    '''
    This function does the following:
        1) computes Otsus threshold for a specified number of bins which separate the FED image in terms of pixel intensity
           or FED magnitude,
        2) computes histogram (not currently used but can be implemented)
        3) draws distribution curve and histogram bars (normalized) as the pdf (probability density function)
        
    Args:
        -) ax = axis to draw the distribution figure on
        -) field = data field to threshold (FED)
        -) bins = number of bins to draw FED magnitude (pixel itensity) data used to illustrate thresholding technique
        -) height_guess = the estimated 'height' of each subplot
    '''
    thresh = threshold_otsu(field,nbins=bins) #compute threshold
    image_h,edge = np.histogram(np.nan_to_num(field.flatten(),0),bins=bins) #compute histogram of FED field
    cents = (edge[1:]+edge[:-1])/2 #edges to centers
    #Plot distribution KDE curve (kernal density), and overlay histogram bars (normalized)
    dist = sns.distplot(np.nan_to_num(field.flatten(),0),bins=bins,ax=ax,norm_hist=True,
                       hist_kws={'color':'black','edgecolor':'k','linewidth':2},
                       kde_kws={'color':'k','linewidth':1})
    #Draw vertical lines to mark threshold value
    ax.vlines(thresh,0,height_guess,color='k',linewidth=4,alpha=0.3)
    ax.vlines(thresh,0,height_guess,color='C3')
    ax.set_ylim(0,height_guess)
    return(dist,thresh)


#################################################################
#DATA: SUBSETTING (BY TIME) AND SAMPLING                        #
#################################################################
#-------------------------------
#SAMPLE SEGMENT FLASH RATES
#-------------------------------
def get_data(case,set_dt):
    '''
    This function opens the LMA data for each case and chunkcs the data into increments spanning the desired time-interval length, or time-delta.
    Arguments are:
        -) case = selected case, e.g., OK-0621,
        -) set_dt= time_delta selection, e.g., 1min, 5min, 10min, etc
        
    Returns:
        -) get_lma_time = chunked lma time data in seconds since start of day format,
        -) get_lmax = flash initiation x coordinates chunked by time
        -) get_lmay = flash initiation y coordinates chunked by time
        -) get_lmaz = flash initiation z coordinates chunked by time
        -) get_area = flash areas chunked by time
        -) get_fid. = flash ids chunked by time
        -) grid.    = each cases sampling grid
        -) time_frames = time frames defining the analysis period for each case.
        
    !! ATTN !! This function is no longer used. get_data is kept in PlottingFunctions.py to exemplify the method by which data are chuncked by time.
    The reason for this is due to the flash sorted files being too large to expect any user to download with the sole expectation to reproduce the experiments of 
    this study. If the flash sorted data is requested, then this function may be used to show how this process was done. - 04/20/23 VS
    '''
    #Read in parameters:
    #------------------
    target      =f'CaseParams/{set_dt}/FlashGriddingParams_{case}.txt'
    params      = eval(open(target, 'r').read())
    case        = params['Case']
    network     = params['network']
    network_lon = params['network_lon']
    network_lat = params['network_lat']
    lat_ranges  = params['lat_range']
    lon_ranges  = params['lon_range']
    spacing     = params['spacing']
    dtime       = params['dt']
    start       = params['start_time']
    end         = params['end_time']
    grid_bnds   = params['grid_extent']
    grid_dx     = params['grid_spacing']
    xover       = params['xover']

    #Point Buffer
    buffer = 3

    year = int(case[:4])
    mo   = int(case[4:6])
    day  = int(case[6:])

    if xover == True: #add one to day if there is a time crossover
        shift = 1
    else:
        shift = 0
    base_date   = dt.datetime(year,mo,day,0,0)
    start_frame = dt.datetime(year,mo,day,int(start[:2]),int(start[2:4]),int(start[4:]))
    end_frame   = dt.datetime(year,mo,day+shift,int(end  [:2]),int(end  [2:4]),int(end  [4:]))

    #Grid sampling
    #--------------------
    print('Setting up sampling grid..')
    gsampling = xr.open_dataset(f'Output/{set_dt}/TrackedData/{case[2:]}/{case[2:]}_sample_grid_dx10.nc')
    grid      = gsampling.sample_line.values

    start_seconds = (start_frame - base_date).total_seconds()
    end_seconds   = (end_frame   - base_date).total_seconds()
    t_frames      = gsampling.coords['time'].values
    print(t_frames.shape)

    #Open flash sorted data
    #---------------------
    print('Opening flash sorted data.')
    flash_sorted = xr.open_dataset(f'LightningData/LMA/sorted/{year}-{str(mo).zfill(2)}-{str(day).zfill(2)}-{network}_QC.nc')

    #Get flash sorted data for analysis
    #---------------------
    flash_lat,flash_lon,flash_alt = flash_sorted.flash_center_latitude.values,flash_sorted.flash_center_longitude.values,flash_sorted.flash_center_altitude.values
    flash_time = flash_sorted.flash_time_start.values
    flash_dur  = flash_sorted.flash_duration.values
    flash_size = flash_sorted.flash_area.values
    flash_eng  = flash_sorted.flash_energy.values
    flash_id   = flash_sorted.flash_id.values

    src_lon,src_lat,src_alt = flash_sorted.event_longitude.values,flash_sorted.event_latitude.values,flash_sorted.event_altitude.values
    src_time                = flash_sorted.event_time.values
    src_pwr                 = flash_sorted.event_power.values
    src_parent_id           = flash_sorted.event_parent_flash_id.values

    #Start map projection
    #---------------------
    print('Projecting LMA points onto LMA grid.')
    geo,proj,(nlon,nlat) = bk.LMA_projection(network,network_lat,network_lon)
    lma_x,lma_y,lma_z = proj.fromECEF(*geo.toECEF(flash_lon,flash_lat,flash_alt))
    src_x,src_y,src_z = proj.fromECEF(*geo.toECEF(src_lon,src_lat,src_alt))

    #For LMA file times:
    ns = 1e-9
    lma_time = np.array([(dt.datetime.utcfromtimestamp(flash_time[i].astype(dt.datetime) * ns) - base_date).total_seconds()
                                                       for i in range(len(flash_time))])

    src_times= np.array([(dt.datetime.utcfromtimestamp(src_time[i].astype(dt.datetime) * ns) - base_date).total_seconds()
                                                       for i in range(len(src_time))])


    #Get Time Subsets:
    #-------------------
    print("Subsetting LMA points by analysis time-frames.")
    t_bnds       = t_frames.copy() + (int(dtime))
    #lma
    get_lma_time = np.array([lma_time[(lma_time>=ti)   & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_lmax     = np.array([lma_x[(lma_time>=ti)      & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_lmay     = np.array([lma_y[(lma_time>=ti)      & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_lmaz     = np.array([lma_z[(lma_time>=ti)      & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_area     = np.array([flash_size[(lma_time>=ti) & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_eng      = np.array([flash_eng[(lma_time>=ti)  & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    get_fid      = np.array([flash_id [(lma_time>=ti)  & (lma_time<tf)]    for ti,tf in zip(t_frames,t_bnds)])
    
    return(get_lma_time,get_lmax,get_lmay,get_lmaz,get_area,get_fid,grid,t_frames)

def get_samples(buffer,case): #was (data,buffer)
    '''
    Function to sample the LMA data at each sample point of the sampling grid. Accepts the following arguments:
    
        -) data = tuple of the returned data variables from get_data(),
        -) buffer = buffer size to draw sample circle around each sample point to collect initiation counts and locations
        
    Returns:
        -) all_areas = sampled flash areas
        -) big_areas = sampled flash areas >= 4 km^2
        -) small_areas= sampled flash areas < 4km^2
        -) all_x = sampled x coords of flash initiations
        -) all_y = sampled y coords of flash initiations
        -) all_z = sampled z coords of flash initaitions
        -) ids = sampled ids of flash initiations
        -) flash_rate = sample segment flash rates
        '''
    #Old method relied on using flash sorted files directly to generate data tuple. Problem was files were too large.
    ###lma_time,lmax,lmay,lmaz,area,fid,grid,tframes = data
    #New method uses data written out that have already been sampled:
    data = xr.open_dataset(f'LightningData/LMA/sorted/{case[:4]}-{case[4:6]}-{case[6:]}-OKLMA_SAMPLED.nc')
    lma_time = data.lma_time.values
    lmax     = data.lma_x.values
    lmay     = data.lma_y.values
    lmaz     = data.lma_z.values
    area     = data.lma_area.values
    fid      = data.flash_id.values
    grid     = data.samp_grid.values
    tframes  = data.frames.values
    
    #Now get initiations:
    #Get samples in each circle through length of storm (front-to-back)
    all_areas,small_areas,big_areas = [],[],[] #initialize arrays
    allx,ally,allz = [],[],[]
    ids = []
    flash_rate = []
    #Start iterations over time
    for time in np.arange(len(tframes)):
        #Open sampling grid
        line  = grid[:,time,:,:]
        lx = line[:,:,0]
        ly = line[:,:,1]
        #Convert lma initiation points to units km and define variabiles for area, time, and id
        #For new method, mask out nans in flash arrays:
        nan_mask = np.isfinite(lmax[time])
        vx = lmax[time][nan_mask]*1e-3
        vy = lmay[time][nan_mask]*1e-3
        vz = lmaz[time][nan_mask]*1e-3
        varea = area    [time][nan_mask]
        vtime = lma_time[time][nan_mask]
        vid   = fid     [time][nan_mask]
        
        #Start iteration over segments
        for j in range(line.shape[1]):
            #Start nested iteration of each segments points
            for s in range(line.shape[0]):
                #Get mask of indices within sample point circular buffer
                mask = (np.sqrt((lx[s,j]-vx)**2. + (ly[s,j]-vy)**2.) <= buffer)
                #Subset all variables to only get points within each points buffer
                get_area  = varea[mask]
                small_mask= (get_area<4) #Get small area mask for small flash rates subset
                big_mask  = (get_area>=4)#Get big area mask for big area subset
                good_id   = vid[mask]
                get_small_area = get_area[small_mask]
                get_big_area   = get_area[big_mask  ]
                #Define LMA points in buffer and count the number of points
                get_x = vx[mask]
                get_y = vy[mask]
                get_z = vz[mask]
                get_fr= get_x.shape[0]
                #Append to lists initialized above. Additional fields for extra analyses if user desires to inspect these properties
                all_areas.append(get_area);big_areas.append(get_big_area);small_areas.append(get_small_area)
                allx.append(get_x);ally.append(get_y);allz.append(get_z)
                ids.append(good_id)
                flash_rate.append(get_fr)
                
    #Note: the reshaped arrays here are specifically hard-coded assuming 10 sample segments each with 100 samples. 
    #if sampling grids differ in size, must change numbers here. We keep them constant for figure reproduction.
    all_areas   = np.array(all_areas).reshape(len(tframes)  ,10,100)
    big_areas   = np.array(big_areas).reshape(len(tframes)  ,10,100)
    small_areas = np.array(small_areas).reshape(len(tframes),10,100)
    allx        = np.array(allx).reshape(len(tframes)       ,10,100)
    ally        = np.array(ally).reshape(len(tframes)       ,10,100)
    allz        = np.array(allz).reshape(len(tframes)       ,10,100)
    ids         = np.array(ids).reshape(len(tframes)        ,10,100)
    flash_rate  = np.array(flash_rate).reshape(len(tframes) ,10,100)
    
    return(all_areas,big_areas,small_areas,allx,ally,allz,ids,flash_rate)

    
    
#----------------------------------------------
#INTERPOLATED 3D FED CROSS-SECTIONS
#----------------------------------------------
def fed_interp(tframes,field,glons,glats,galts,sampling,sindx,eindx,geo,proj,method='nearest'):
    '''
    This function interpolates 3D FED data onto the LTR sampling grid. Interpolation is done to demonstrate the utility of not only 
    examining flash rate variability, but how flash activity is structured through a linear storm system. 
    
    Arguments:
        -) tframes = time frames of FED grid,
        -) field   = 3D FED grid field,
        -) glons   = grid longitude values
        -) glats   = grid latitude values,
        -) galts   = grid altitude values,
        -) sampling= LTR sampling grid for case,
        -) sindx   = start index of FED time frame,
        -) eindx   = end index of FED time frame,
        -) method  = interpolation method, default is nearest.
    
    The sindx and eindx values are recommended to be defined to iterate over a single time frames--which does defeat the purpose of a loop. 
    The loop is kept as the sampled 3D FED array may be expanded to hold other interpolated time frames for various analysis needs.
    
    Returns:
        -) samps = array of the 3D interpolated FED grid onto the LTR sampling grid.
    '''
    #Initialize array to write 3D FED interpolated field on sampling grid:
    samps = []
    #Iterate over time; here currently set to only interpolating one time. Indices can be changed if desired.
    for i in range(tframes)[sindx:eindx]:
        #Iterate over all FED altitudes
        for ups in range(field.shape[1]):
            #Set field name for interpolating
            dat = field[i,ups,:,:]
            #Transform grids
            lons,lats,alts          = np.meshgrid(glons,glats,galts)
            l_ecefx,l_ecefy,l_ecefz = geo.toECEF(lons,lats,alts)
            lx,ly,lz                = proj.fromECEF(l_ecefx,l_ecefy,l_ecefz)
            lx = lx*1e-3
            ly = ly*1e-3
            use_x,use_y = lx[0,:,0],ly[:,0,0] #Get x and y values of grid in 1D arrays for interpolating
        
            #Sample/Interpolate: Iterate over each sample point on sampling grid
            for s in range(sampling.shape[0])[:]:
                #Define sampling grid coordinates
                sampx = sampling[s,i,:,0] #e.g. 100,time,10,2
                sampy = sampling[s,i,:,1]
                #Interpolate:
                f_interp = interpn((use_x,use_y),dat[:,:].T,(sampx,sampy),bounds_error=False,method=method)
                samps.append(f_interp)
    #Reshape array to be in: (alt,sample number, sample segment)
    samps = np.array(samps).reshape(field.shape[1],sampling.shape[0],sampling.shape[2])
    return(samps)



#################################################################
#FIGURES: Generate all Performance and Sampling Figures         #
#################################################################
#-----------------
#METHODOLOGY PLOTS
#-----------------
def ltr_method(half,lon,lat,fed_1min,fed_5min,fed_10min,e1_xcoord,e1_ycoord,e5_xcoord,e5_ycoord,e10_xcoord,e10_ycoord,
               g1_xcoords,g1_ycoords,g5_xcoords,g5_ycoords,g10_xcoords,g10_ycoords,save=False):
    '''
    This function generates the LTR methodology figure which illustrates:
    
        1) FED differences across different time intervals,
        2) Smoothed FED used to identify FED objects (FOBs),
        3) Tracked ellipse and sample axis and points overlaid onto FED,
        4) Tracked ellipse, sample axis, and sample grid overlaid onto FED
    '''
    # Define figure axis and figure object: [FIGURE FOR OK-0621 ONLY]
    #-----------------------------------------
    fix,ax = plt.subplots(4,3,figsize=(10,9),subplot_kw={'projection':ccrs.PlateCarree()})
    
    #Set constants and parameters for plotting:
    #-----------------------------------------
    idx_1min =100        #time frame index for 1 minute interval FED
    idx_5min =20         #time frame index for 5 minute interval FED
    idx_10min=10         #time frame index for 10 minute interval FED
    cmap = cm.cm.thermal #set color map
    alpha = .8           #figure transparancy
    
    #FED Figures at 1, 5, and 10 minute intervals. Figures are log-scaled
    #-----------------------------------------
    ax[0,0].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_1min [idx_1min ],0)) ,alpha=alpha ,cmap=cmap,transform=ccrs.PlateCarree())
    ax[0,1].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_5min [idx_5min ] ,0)),alpha=alpha ,cmap=cmap,transform=ccrs.PlateCarree())
    ax[0,2].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_10min[idx_10min],0)) ,alpha=alpha ,cmap=cmap,transform=ccrs.PlateCarree())
    
    #Smoothed FED figures using specified smoothing parameters (pixel neighborhood size)
    #-----------------------------------------
    gauss_alpha   = 1  #general smoothing parameter (not used)
    gauss_alpha_1 = 10 #1 minute smoothing parameter
    gauss_alpha_5 = 5  #5 minute smoothing parameter
    gauss_alpha_10= 5  #10 minute smoothing parameter
    
    #Now define variables for log-scaled FED grids at specified time index, remove 0 points, and smooth FED fields.
    #Masked object then is used to further restrict FED footprint to only large values.
    #dt = 1 FED grid
    f1   = np.log10(fed_1min [idx_1min ])
    f1[~np.isfinite(f1)] = 0
    f1   = gf(f1,gauss_alpha_1)
    f1   = np.ma.MaskedArray(f1,mask=f1<.05)
    #dt = 5 FED grid
    f5   = np.log10(fed_5min [idx_5min ])
    f5[~np.isfinite(f5)] = 0
    f5   = gf(f5,gauss_alpha_5)
    f5   = np.ma.MaskedArray(f5,mask=f5<.05)
    #dt = 10 FED grid
    f10   = np.log10(fed_10min [idx_10min ])
    f10[~np.isfinite(f10)] = 0
    f10   = gf(f10,gauss_alpha_10)
    f10   = np.ma.MaskedArray(f10,mask=f10<.05)
    
    #Plot smoothed FEDs
    ax[1,0].pcolormesh(lon,lat,f1,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[1,1].pcolormesh(lon,lat,f5,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[1,2].pcolormesh(lon,lat,f10,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    
    #Plot ellipses:
    #----------------------------------------
    #First plot the FED (non-smoothed) for each time interval
    ax[2,0].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_1min [idx_1min ],0)) ,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[2,1].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_5min [idx_5min ] ,0)),alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[2,2].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_10min[idx_10min],0)) ,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    
    #Second, plot tracking ellipses (from their transformed boundary coordinates)
    ax[2,0].plot(e1_xcoord[idx_1min,:],e1_ycoord[idx_1min,:],'-k',transform=ccrs.PlateCarree())
    ax[2,1].plot(e5_xcoord[idx_5min,:],e5_ycoord[idx_5min,:],'-k',transform=ccrs.PlateCarree())
    ax[2,2].plot(e10_xcoord[idx_10min,:],e10_ycoord[idx_10min,:],'-k',transform=ccrs.PlateCarree())
    
    #Third, plot the sample axis and (n) points that define each sample segment, The below first plots black scatters to generate an outline for the markers
    ax[2,0].scatter(g1_xcoords[half,idx_1min,:]  ,g1_ycoords[half,idx_1min,:]  ,marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    ax[2,1].scatter(g5_xcoords[half,idx_5min,:]  ,g5_ycoords[half,idx_5min,:]  ,marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    ax[2,2].scatter(g10_xcoords[half,idx_10min,:],g10_ycoords[half,idx_10min,:],marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    
    #Fourth, plot colored marker above black markers so they stand out from background
    ax[2,0].plot(g1_xcoords[half,idx_1min,:]  ,g1_ycoords[half,idx_1min,:]  ,'-k',transform=ccrs.PlateCarree())
    ax[2,1].plot(g5_xcoords[half,idx_5min,:]  ,g5_ycoords[half,idx_5min,:]  ,'-k',transform=ccrs.PlateCarree())
    ax[2,2].plot(g10_xcoords[half,idx_10min,:],g10_ycoords[half,idx_10min,:],'-k',transform=ccrs.PlateCarree())
    
    #Fifth, annotate the sample axis points as a range from 0-9 (0-based)
    segs = np.arange(10).astype(str)
    [ax[2,0].text(g1_xcoords[half,idx_1min,i]-.05,g1_ycoords[half,idx_1min,i]-.5,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    [ax[2,1].text(g5_xcoords[half,idx_5min,i]-.05,g5_ycoords[half,idx_5min,i]-.5,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    [ax[2,2].text(g10_xcoords[half,idx_10min,i]-.05,g10_ycoords[half,idx_10min,i]-.5,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    
    #Sixth, annotated the identified sample segements
    ax[2,0].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-1,'Sample Segments',color='C3',weight='bold')
    ax[2,1].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-1,'Sample Segments',color='C3',weight='bold')
    ax[2,2].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-1,'Sample Segments',color='C3',weight='bold')
    
    
    #Finally, overlay the full sample grid for each time interval FED.
    #---------------------------------------
    #Again, first plot the FED (non-smoothed) for reference
    ax[3,0].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_1min [idx_1min ],0)) ,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[3,1].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_5min [idx_5min ] ,0)),alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    ax[3,2].pcolormesh(lon,lat,np.log10(np.nan_to_num(fed_10min[idx_10min],0)) ,alpha=alpha,cmap=cmap,transform=ccrs.PlateCarree())
    
    #Now, plot the sample grid x and y coordinates (lon, lat since in geographic system here).
    ax[3,0].scatter(g1_xcoords[:,idx_1min,:],g1_ycoords[:,idx_1min,:],    marker='+',s=2,color='k',alpha=0.6,linewidth=0.5,transform=ccrs.PlateCarree())
    ax[3,1].scatter(g5_xcoords[:,idx_5min,:],g5_ycoords[:,idx_5min,:],    marker='+',s=2,color='k',alpha=0.6,linewidth=0.5,transform=ccrs.PlateCarree())
    ax[3,2].scatter(g10_xcoords[:,idx_10min,:],g10_ycoords[:,idx_10min,:],marker='+',s=2,color='k',alpha=0.6,linewidth=0.5,transform=ccrs.PlateCarree())
    
    #Replot the center points that define the sample axis
    ax[3,0].scatter(g1_xcoords[half,idx_1min,:]  ,g1_ycoords[half,idx_1min,:]  ,marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    ax[3,1].scatter(g5_xcoords[half,idx_5min,:]  ,g5_ycoords[half,idx_5min,:]  ,marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    ax[3,2].scatter(g10_xcoords[half,idx_10min,:],g10_ycoords[half,idx_10min,:],marker='s',color='C3',edgecolor='k',linewidth=1,transform=ccrs.PlateCarree())
    
    #Annotate the sample segment numbers
    segs = np.arange(10).astype(str)
    [ax[3,0].text(g1_xcoords[half,idx_1min,i]-.07,g1_ycoords[half,idx_1min,i]-1.7,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    [ax[3,1].text(g5_xcoords[half,idx_5min,i]-.07,g5_ycoords[half,idx_5min,i]-1.7,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    [ax[3,2].text(g10_xcoords[half,idx_10min,i]-.07,g10_ycoords[half,idx_10min,i]-1.7,segs[i],color='C3',weight='bold') for i in range(len(segs))]
    
    #Annotate the sample segments
    ax[3,0].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-2.1,'Sample Segments',color='C3',weight='bold')
    ax[3,1].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-2.1,'Sample Segments',color='C3',weight='bold')
    ax[3,2].text(g1_xcoords[half,idx_1min,4]-1.2,g1_ycoords[half,idx_1min,4]-2.1,'Sample Segments',color='C3',weight='bold')
    
    
    #Set axis titles: Shows progression of LTR steps
    #---------------------------------------
    ax[0,0].text(-.1,.25,r'$\rm log_{10}(FED)$',transform=ax[0,0].transAxes,rotation=90,fontsize=13)
    ax[1,0].text(-.1,.05,r'Smooth for ID',transform=ax[1,0].transAxes,rotation=90,fontsize=13)
    ax[2,0].text(-.1,.30,r'Tracking',transform=ax[2,0].transAxes,rotation=90,fontsize=13)
    ax[3,0].text(-.1,.15,r'Sample Grid',transform=ax[3,0].transAxes,rotation=90,fontsize=13)
    
    
    #Set state lines and axes extents for the mapped figure:
    #---------------------------------------
    scale = '50m'
    states50 = cfeature.NaturalEarthFeature(
                category='cultural',
                name='admin_1_states_provinces_lines',
                scale=scale,
                facecolor='none',
                edgecolor='gray')
    [axs.add_feature(states50, zorder=2, linewidth=2.,linestyle='-') for axs in ax.flatten()]
    [axs.set_extent([-99.9,-95.,33.4,37.2], crs=ccrs.PlateCarree()) for axs in ax.flatten()]
    plt.subplots_adjust(wspace=0.0,hspace=0.1)
    
    #Set axis titles: For specifing the time interval used to construct FEDs
    #---------------------------------------
    ax[0,0].set_title('1 minute' ,fontsize=13)
    ax[0,1].set_title('5 minutes' ,fontsize=13)
    ax[0,2].set_title('10 minutes',fontsize=13)
    
    #Annotate Subplots: For referencing in paper
    #---------------------------------------
    letters = ['A)','B)','C)','D)','E)','F)',
               'G)','H)','I)','J)','K)','L)']
    [axs.text(.05,.85,letter,transform=axs.transAxes,fontsize=14,color='C3',weight='bold') for (axs,letter) in zip(ax.flatten(),letters)]
    sigs = np.array([10,5,5])
    [axs.text(.05,.05,r'$\sigma=$'+f'{sigs[i-3]} grid point(s)',transform=axs.transAxes,fontsize=12,color='C3',weight='bold') for (i,axs) in enumerate(ax.flatten()) if (i >2) and (i<6)]
    if save==True:
        plt.savefig('PaperFigures/METHOD-OK210612.pdf',dpi=160,bbox_inches='tight')
    return(f1,f5,f10)

#----------------------
#OTSUS Threshold Plots
#----------------------
def otsu_plots_gen(f1,f5,f10,save=False):
    #Plot Otsu's Threshold and Generate Figure axis:
    #-------------------------------------
    fig,ax = plt.subplots(3,1,figsize=(4,10))
    #Generate distribution plots for each time interval
    #Choice of 20 bins to allow for wider histogram bars that are easier to see, typically use 256 for number of colors in images
    d1  ,d1thresh  = otsu_plots(ax[0],f1 ,20,150)
    d5  ,d5thresh  = otsu_plots(ax[1],f5 ,20,30)
    d10 ,d10thresh = otsu_plots(ax[2],f10,20,20)
    
    #Annotate divisions between where FED is non-existent, and where it exhibits large non-zero magnitudes
    ax[0].text(.45,.9,'Non-zero FED',fontsize=11,color='k',transform=ax[0].transAxes)
    ax[1].text(.45,.9,'Non-zero FED',fontsize=11,color='k',transform=ax[1].transAxes)
    ax[2].text(.45,.9,'Non-zero FED',fontsize=11,color='k',transform=ax[2].transAxes)
    #Zero FED magnitude region
    ax[0].text(.01,.9,'Zero FED',fontsize=11,color='k',transform=ax[0].transAxes)
    ax[1].text(.01,.9,'Zero FED',fontsize=11,color='k',transform=ax[1].transAxes)
    ax[2].text(.01,.9,'Zero FED',fontsize=11,color='k',transform=ax[2].transAxes)
    #Annotate The threshold computed for these time frames and time intervals 
    ax[0].text(.36,.45,r'OtsuThresh={0:.2f}'.format(d1thresh) ,fontsize=12,color='k',transform=ax[0].transAxes)
    ax[1].text(.36,.45,r'OtsuThresh={0:.2f}'.format(d5thresh) ,fontsize=12,color='k',transform=ax[1].transAxes)
    ax[2].text(.36,.45,r'OtsuThresh={0:.2f}'.format(d10thresh),fontsize=12,color='k',transform=ax[2].transAxes)
    
    #Figure management-draw axis grid and set labels and annotations for in-text referencing
    [axs.grid() for axs in ax.flatten()]
    [axs.set_ylabel('PDF',fontsize=12) for axs in ax.flatten()]
    [axs.set_xlabel(r'$\rm log_{10}(FED_{smooth})$',fontsize=12) for axs in ax.flatten()]
    [axs.tick_params(labelsize=11) for axs in ax.flatten()]
    ax[0].text(.9,.1,'A',transform=ax[0].transAxes,fontsize=16,color='C3',weight='bold')
    ax[1].text(.9,.1,'B',transform=ax[1].transAxes,fontsize=16,color='C3',weight='bold')
    ax[2].text(.9,.1,'C',transform=ax[2].transAxes,fontsize=16,color='C3',weight='bold')
    plt.tight_layout()
    if save==True:
        plt.savefig('PaperFigures/OBJECT_ID_OTSU-THRESH-OK210612.pdf',dpi=160,bbox_inches='tight')

#--------------------------
#Sample Segment Flash Rates
#--------------------------
def plot_seg_fr(data1,samps1,data2,samps2,total1,total2,tc1,tc2,idx_5min,save=False):
    '''
    This function plots the segment maximum flash rates with the storm system total flash rate overlaid for A) OK-0621 and B) OK-1021.
    Panels C) and D) illusrate the fraction of the total flash rates of all combined segements to the total storm flash rates to demonsrate the 
    importance of examining local flash rate change in contrast to those describing the bulk storm system as a whole.
    
    Arguments:
        -) data1 & data2 = time frame chunked flash data
        -) samps1 & samps2 = flash data sampled on sampling grid
        -) total1 & total 2 = total storm flash rates for both cases
        -) tc1 & tc2 = time frame centers for flash rate histograms
        -) idx_5min = time frame to be plotted
    '''
    tframes1=data1.frames.values
    tframes2=data2.frames.values
    
    #Define figure and figure axes:
    #-----------------------------
    fig,ax = plt.subplots(2,2,figsize=(15,8))
    
    #Define line colors and right-hand axes for total flash rates
    #-----------------------------
    colors = plt.cm.inferno(np.linspace(.3,1,10))
    tax = ax[0,0].twinx()
    tax2= ax[0,1].twinx()

    #Plot sample segment flash rates correponding to the colors chosen above, and save the line objects to generate
    #the legend. Plot the total flash rate using the twin axis after iterations are done.
    #-----------------------------
    #For OK-0621
    alines = []
    for samp1 in range(10):
        ax[0,0].plot(tframes1,np.nanmax(samps1[-1][:,samp1,:],axis=1),linewidth=5,alpha=0.5,color='k',zorder=10)
        ls, = ax[0,0].plot(tframes1,np.nanmax(samps1[-1][:,samp1,:],axis=1),linewidth=3,alpha=0.9,color=colors[samp1],zorder=10)
        alines.append(ls)
    tax.plot(tc1,total1[0],'k-',linewidth=5,alpha=1,zorder=-2)
    #For OK-1027
    for samp2 in range(10):
        ax[0,1].plot(tframes2,np.nanmax(samps2[-1][:,samp2,:],axis=1),linewidth=5,alpha=0.5,color='k')
        ax[0,1].plot(tframes2,np.nanmax(samps2[-1][:,samp2,:],axis=1),linewidth=3,alpha=0.9,color=colors[samp2])
    tax2.plot(tc2,total2[0],'k',linewidth=5,alpha=1)

    #Plot fraction of sampled flash rates, by how much do each segments flash rates represent the total? See here
    #------------------------------
    ax[1,0].plot(data1.frames.values,np.nanmax(np.nansum(samps1[-1],axis=1),axis=1)/total1[0] * 100,linewidth=5,color='k',alpha=0.5)
    ax[1,1].plot(data2.frames.values,np.nanmax(np.nansum(samps2[-1],axis=1),axis=1)/total2[0] * 100,linewidth=5,color='k',alpha=0.5)
    ax[1,0].plot(data1.frames.values,np.nanmax(np.nansum(samps1[-1],axis=1),axis=1)/total1[0] * 100,linewidth=3,color='C3')
    ax[1,1].plot(data2.frames.values,np.nanmax(np.nansum(samps2[-1],axis=1),axis=1)/total2[0] * 100,linewidth=3,color='C3')

    #Generate legend from the alines fields which allow for labeling the color to the sample segment number
    #------------------------------
    ax[0,0].legend(alines,np.arange(10).astype(str),ncol=5,fancybox=True,shadow=True,title='Sample Segment',loc='upper right')
    ax[0,1].legend(alines,np.arange(10).astype(str),ncol=5,fancybox=True,shadow=True,title='Sample Segment')

    #Plotted Line Layering: Send total flash rate to back to keep segment flash rates in forefront
    #------------------------------
    #OK-0621
    ax[0,0].set_zorder(tax.get_zorder()+1)
    ax[0,0].set_frame_on(False)
    #OK-1027
    ax[0,1].set_zorder(tax2.get_zorder()+1)
    ax[0,1].set_frame_on(False)

    #Figure properties and labeling:
    #-----------------------------
    [axs.tick_params(labelsize=14) for axs in ax.flatten()]
    [axs.tick_params(labelsize=14) for axs in [tax,tax2]]
    [axs.set_xlabel('Time (s)',fontsize=15) for axs in ax.flatten()]
    [axs.set_ylabel('Segment Max Flash Rate (5min)',fontsize=15) for axs in [ax[0,0],ax[0,1]]]
    [axs.set_ylabel('Total Flash Rate (5min)',fontsize=15) for axs in [tax,tax2]]
    [axs.set_ylabel('Percent Total Flash Rate',fontsize=15) for axs in [ax[1,0],ax[1,1]]]
    [axs.grid(alpha=0.9,axis='x') for axs in ax.flatten()]
    [axs.set_xlim(data1.frames.values.min(),data1.frames.values.max()) for axs in [ax[0,0],ax[1,0]]]
    [axs.set_xlim(data2.frames.values.min(),data2.frames.values.max()) for axs in [ax[0,1],ax[1,1]]]
    #Annotations for reference in paper
    letters = ['A)','B)','C)','D)']
    [axs.text(.01,.92,letter,fontsize=25,color='C3',weight='bold',transform=axs.transAxes) for letter,axs in zip(letters,ax.flatten())]
    ax[0,0].set_title('OK-0621',fontsize=16)
    ax[0,1].set_title('OK-1021',fontsize=16)
    #Save figure
    #-------------------------------
    plt.tight_layout()
    if save==True:
        plt.savefig(f'PaperFigures/FLASHRATES-{idx_5min}.pdf',dpi=160,bbox_inches='tight')

#-------------------------
#3D Cross Section Figures
#-------------------------
def samples_3d(tx,ty,samps1,samps,index=35,save=False):
    '''
    This function plots 2D cross sections through the sampling grid in 3D defined by the sample segment axis, sample points, and altitude.
    Arguements:
        -) samps1 = flash rate data overlaid ontop of cross-sections.
        -) samps  = 2D cross section data interpolated onto sample grid
        -) index  = time index to be plotted.
    '''
    #Set new flash rates variable for plotting flash rate shapes over each segments vertical cross section
    flash_rates1 = samps1[-1][index,:,:]
    #Set variable to plot sample segment vertical cross-sections
    use = np.log10(samps[:,:,:])
    #Mask the array to omit 0 values
    m = (np.ma.MaskedArray(use,mask=(use==0) & ~np.isfinite(use)))
    
    #Setup figure
    fig,ax = plt.subplots(1,1,figsize=(10,40),subplot_kw={'projection':'3d'})
    #Iterate over sample segments
    for i in range(m.shape[2])[:]:
        #Need to add some random noise else the 3D plotting won't work and mask out values < 0.01
        ma = np.nan_to_num(m[:,:,i],0.0) + np.random.randn(m.shape[0],m.shape[1])/1000
        mask = ma>.01
        try:
            #If no issues with plotting, contours are generated in 3D
            ax.contour(tx,np.ma.MaskedArray(ma,mask=ma<0.002),ty*1e-3,levels=80,zdir='y',vmin=0,vmax=1.5,offset=i*1,cmap=plt.cm.magma,alpha=0.8,zorder=-1*i)    
        except:
            #Else, only random noise for a segment will be drawn
            ax.contour(tx,(np.abs(np.random.randn(59,100)))/1000,ty,vmin=.8,vmax=1,zdir='y')
        #Plot the flash rate trends above each cross-section--note these are normalized!
        ax.plot(np.linspace(0,100,100),np.repeat(i,100),flash_rates1[i,:]/np.nanmax(flash_rates1[i,:]) + 14,zdir='z',color='k')
        
    #Plot total FED through length of system
    ax.contourf(tx,np.log10(np.nansum(samps,axis=2)),ty*1e-3,vmin=0,vmax=2,zdir='y',offset=10,cmap=plt.cm.magma)
    #Set figure axis limits and labels
    ax.set(xlim=(0,80),ylim=(0,10),zlim=(2,15),
           xlabel='Segment Samples',ylabel='Segment Number',zlabel='Altitude (km)')
    #Set azimuthal view angle
    ax.view_init(elev=10,azim=-35)
    #Set figure title and save i the figure
    ax.set_title(f'{dt.datetime(2021,6,12) + dt.timedelta(seconds=28500)} UTC',y=.9,fontsize=17)
    ax.set_box_aspect(aspect=(1,2,1))
    if save == True:
        plt.savefig(f'PaperFigures/FLASHFEDs-{idx_5min}.pdf',dpi=160,bbox_inches='tight')
    
    
#----------------------------------------------
#INTERPOLATED SPACE-TIME FIGURES
#----------------------------------------------

def space_time(samps1,flash_field,samps2,flash_field2,xm,ym,xm2,ym2,data1,data2,which_point,save=False):
    '''
    This function generates 3 different figure panels per case. These panels are as follow:
    
        A & D) Max flash rates through sample grid plotted against sample segment. Max flash rates computed by finding maximum of each sample segment's
               flash rate through all time frames and plotting them in "space", or as a function of the sampling grid dimensions (i.e., sample number and sample segment).
               The panel has dimensions of 100 samples by 10 segments.
        B & E) Max flash rates through time. Max flash rates are computed through the sampling grid width at each time frame to generate a maximum flash rate 
               per sample segment figure. Dimensions of figure is #TimeFrames by 10 segments.
        C & F) Max flash rates interpolated onto 50th sample (for each segment) for all time frames to illustrate evolution of flash activity in space and time as each
               storm system moved through the analysis domain.
               
    Arguments: 
        -) samps1 & samps2 = flash rates for OK-0621 and OK-1021, respectively.
        -) flash_field & flash_field2 = interpolated maximum flash rate through each time frame and at the 50th sample for each case (Panels: C&F)
        -) xm & xm2 = x-grid coordinate for plotting the space-time figure panels
        -) ym & ym2 = y-grid coordinate for plotting the space-time figure panels
        -) data1 & data2 = time frame array for each case
        -) which_point = 50th point of sample grid
    '''
    fig,ax = plt.subplots(2,3,figsize=(10,6))
    #OK-0621
    #Consolidated Plots
    ax[0,0].pcolormesh(np.arange(100),np.arange(10),
                           np.log10(np.nanmax(samps1[-1],axis=0)),vmin=0,vmax=2.5,alpha=0.8,cmap=cm.cm.thermal)

    ax[0,1].pcolormesh(data1.frames.values,np.arange(10),
                           np.log10(np.nanmax(samps1[-1],axis=2)).T,vmin=0,vmax=2.5,alpha=0.8,cmap=cm.cm.thermal)
    #Stitched Mosiac
    ax[0,2].contour (xm,ym,np.log10(flash_field),levels=20,vmin=0,vmax=2.5,colors='k',linewidths=0.4)
    ax[0,2].contourf(xm,ym,np.log10(flash_field),levels=20,vmin=0,vmax=2.5,cmap=cm.cm.thermal,alpha=0.8)

    #OK-1021
    #Consolidated Plots
    ax[1,0].pcolormesh(np.arange(100),np.arange(10),
                           np.log10(np.nanmax(samps2[-1],axis=0)),vmin=0,vmax=2.5,alpha=0.8,cmap=cm.cm.thermal)

    ax[1,1].pcolormesh(data2.frames.values,np.arange(10),
                           np.log10(np.nanmax(samps2[-1],axis=2)).T,vmin=0,vmax=2.5,alpha=0.8,cmap=cm.cm.thermal)
    #Stitched Mosiac
    ax[1,2].contour (xm2,ym2,np.log10(flash_field2),levels=20,vmin=0,vmax=2.5,colors='k',linewidths=0.4)
    ax[1,2].contourf(xm2,ym2,np.log10(flash_field2),levels=20,vmin=0,vmax=2.5,cmap=cm.cm.thermal,alpha=0.8)

    ax[0,2].set_xlim(-225,225)
    ax[0,2].set_ylim(-110,110)
    ax[1,2].set_xlim(-150,150)
    ax[1,2].set_ylim(-260,180)

    [axs.grid(alpha=0.5) for axs in ax[:,2]]
    [axs.plot([0,100],[i,i],color='k',linestyle='-',linewidth=0.5) for axs in ax[:,0].flatten() for i in range(10)]
    [axs.set_xlim(0,100) for axs in ax[:,0].flatten()]

    [ax[0,1].plot([data1.frames.values.min(),data1.frames.values.max()],[i,i],color='k',linestyle='-',linewidth=0.5) for i in range(10)]
    [ax[1,1].plot([data2.frames.values.min(),data2.frames.values.max()],[i,i],color='k',linestyle='-',linewidth=0.5) for i in range(10)]

    #Formatting:
    #------------------------------------------
    [axs.set_yticks(np.arange(11)-0.5) for axs in ax[:,0].flatten()]
    [axs.set_yticks(np.arange(11)-0.5) for axs in ax[:,1].flatten()]
    [axs.set_yticklabels((np.arange(11)-1).astype(str)) for axs in ax[:,0].flatten()]
    [axs.set_yticklabels((np.arange(11)-1).astype(str)) for axs in ax[:,1].flatten()]
    [axs.set_ylim(0,10) for axs in ax[:,0].flatten()]
    [axs.set_ylim(0,10) for axs in ax[:,1].flatten()]

    #conditionals used to only provide certain labels to certain panels
    [axs.set_ylabel('Sample Segment',fontsize=13) for i,axs in enumerate(ax.flatten()) if (i!=2) and (i!=5)]
    [axs.set_xlabel('Sample Number',fontsize=13) for i,axs in enumerate(ax.flatten()) if (i!=2) and (i!=5) and (i!=1) and (i!=4)]
    [axs.set_xlabel('Time (s)',fontsize=13) for i,axs in enumerate(ax.flatten()) if (i!=2) and (i!=5) and (i!=0) and (i!=3)]
    [axs.set_ylabel('Y-Direction (km)',fontsize=13) for axs in ax[:,-1].flatten()]
    [axs.set_xlabel('X-Direction (km)',fontsize=13) for axs in ax[:,-1].flatten()]

    #Annotations:
    #------------------------------------------
    #define list of letters used to annotate panels
    alph = list(map(chr,range(97,123)))
    letters = [alph[i].capitalize()+')' for i in range(ax.flatten().shape[0])]
    [axs.text(.01,.91,letter,color='C3',weight='bold',fontsize=15,transform=axs.transAxes) for axs,letter in zip(ax.flatten(),letters)]
    [axs.text(.11,.91,'min=0 max=2.5',color='C3',weight='bold',fontsize=15,transform=axs.transAxes) for axs,letter in zip(ax.flatten(),letters)]
    ax[0,0].set_title('Spatial Maximum Flash Rate',fontsize=14)
    ax[0,1].set_title('Temporal Maximum Flash Rate',fontsize=14)
    ax[0,2].set_title('Flash Rate at Sample: {0}'.format(which_point),fontsize=14)

    ax[0,0].text(-.3,.30,'OK-0621',fontsize=14,weight='bold',color='k',transform=ax[0,0].transAxes,rotation=90)
    ax[1,0].text(-.3,.30,'OK-1021',fontsize=14,weight='bold',color='k',transform=ax[1,0].transAxes,rotation=90)

    plt.tight_layout()
    if save==True:
        plt.savefig(f'PaperFigures/EXAMPLE_USE_5MIN.pdf',dpi=160,bbox_inches='tight')